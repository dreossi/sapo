#include "AutoGenerated.h"

using namespace AbsSyn;


// creates the bundle defined by the model, adding directions and template rows according to assertions
Bundle *getBundleWithAsserts(const InputData &id);

// return i s.t. M[i] = v, or -1 if M does not contain v
int find(const std::vector<std::vector<double>> M, const std::vector<double> v);

// computes a vector having the same direction and length 1
std::vector<double> normalize(std::vector<double> v);

// computes the multiplicative coefficient to normalize vector
double getNormalizationCoefficient(std::vector<double> v);

// given a vector v1 and an offset val, return the new offset of the same constraint
// rescaled wrt v2
double rescale(double val, std::vector<double> v1, std::vector<double> v2);

// checks if two vectors are equal
bool compare (std::vector<double> v1, std::vector<double> v2, double tol);

void printMatrix(const std::vector<std::vector<double>> m);
void printMatrix(const std::vector<std::vector<int>> m);
void printVector(const std::vector<double> v);

AutoGenerated::AutoGenerated(const InputData &m)
{
  using namespace std;
  using namespace GiNaC;

  this->name = "AutoGenerated";

  for (unsigned i = 0; i < m.getVarNum(); i++) {
    this->vars.append(symbol(m.getVar(i)->getName()));
	}

  for (unsigned i = 0; i < m.getParamNum(); i++) {
    this->params.append(symbol(m.getParam(i)->getName()));
	}

  for (unsigned i = 0; i < m.getVarNum(); i++) {
    this->dyns.append(
        m.getVar(i)->getDynamic()->toEx(m, this->vars, this->params));
	}

	this->reachSet = getBundleWithAsserts(m);

  // parameter directions
  if (m.paramDirectionsNum() != 0) {
    vector<vector<double>> pA(2 * m.paramDirectionsNum(),
                              vector<double>(m.getParamNum(), 0));
    for (unsigned i = 0; i < m.paramDirectionsNum(); i++) {
      pA[2 * i] = m.getParamDirection(i);
      for (unsigned j = 0; j < m.getParamNum(); j++)
        pA[2 * i + 1][j] = -pA[2 * i][j];
    }

    vector<double> pb(pA.size(), 0);
    for (unsigned i = 0; i < m.paramDirectionsNum(); i++) {
      pb[2 * i] = m.getParamUB()[i];
      pb[2 * i + 1] = -m.getParamLB()[i];
    }

    this->paraSet
        = new LinearSystemSet(std::make_shared<LinearSystem>(pA, pb));
  }

  // formula
  if (m.isSpecDefined()) {
    this->spec = m.getSpec()->toSTL(m, vars, params);
  } else {
    this->spec = NULL;
  }
}

Bundle *getBundleWithAsserts(const InputData &id)
{
	std::vector<std::vector<double>> directions = id.getDirections();
	std::vector<double> LB = id.getLB(), UB = id.getUB();
	std::vector<std::vector<int>> template_matrix = id.getTemplate();
	
	
	// prepare linear system to find LBs of new directions of asserts
	GiNaC::lst symbols{};
	for (unsigned i = 0; i < id.getVarNum(); i++) {
		GiNaC::symbol s(id.getVar(i)->getName());
		symbols.append(s);
	}
	
	// matrix and offsets of the LS
	std::vector<std::vector<double>> A = directions;
	for (unsigned i = 0; i < directions.size(); i++) {
		A.push_back(get_complementary(directions[i]));
	}
	
	std::vector<double> b = UB;
	for (unsigned i = 0; i < LB.size(); i++) {
		b.push_back(-LB[i]);
	}
	
	LinearSystem LS(A, b);
	
	// directions affected by constraints, and offsets
	std::vector<std::vector<double>> constrDirs{};
	std::vector<double> constrOffsets{};
	
	// for each assertion, add new direction to directions
	// and to a new (or more) template row
	std::vector<int> new_template_row{};
	for (unsigned i = 0; i < id.getAssertNumber(); i++) {
		std::vector<double> new_dir = id.getAssert(i)->getDirection(id);
		std::vector<double> negated_dir = get_complementary(new_dir);
		
//		constrDirs.push_back(new_dir);
//		constrOffsets.push_back(id.getAssert(i)->getOffset(id));
		
		int pos_dir = find(directions, new_dir);
		int pos_negated_dir = find(directions, negated_dir);
		if (pos_dir != -1) {
			constrDirs.push_back(directions[pos_dir]);
			constrOffsets.push_back(rescale(id.getAssert(i)->getOffset(id), new_dir, constrDirs[i]));
			UB[pos_dir] = std::min(UB[pos_dir], constrOffsets[i]);
		} else if (pos_negated_dir != -1) {
			constrDirs.push_back(get_complementary(directions[pos_negated_dir]));
			constrOffsets.push_back(rescale(id.getAssert(i)->getOffset(id), new_dir, constrDirs[i]));
			LB[pos_negated_dir] = std::max(LB[pos_negated_dir], constrOffsets[i]);
		} else {
			constrDirs.push_back(new_dir);
			constrOffsets.push_back(id.getAssert(i)->getOffset(id));
			
			directions.push_back(new_dir);
			UB.push_back(constrOffsets[i]);
		
			// get LB s.t. it doesn't cut points from the polytope
			GiNaC::ex obj_function = 0;
			for (unsigned j = 0; j < new_dir.size(); j++) {
				obj_function += new_dir[j] * symbols[j];
			}
			double min_val = LS.minLinearSystem(symbols, obj_function);
			LB.push_back(min_val);
			
			new_template_row.push_back(directions.size() - 1);
			if (new_template_row.size() == id.getVarNum()) {
				template_matrix.push_back(new_template_row);
				new_template_row.resize(0);
			}
		}
	}
	
	// if last template row is half full, complete it and push to template
	if (new_template_row.size() < id.getVarNum() && new_template_row.size() > 0) {
		for (unsigned i = 0; i < id.getVarNum() - new_template_row.size(); i++) {
			new_template_row.push_back(i);
		}
		std::sort(new_template_row.begin(), new_template_row.end());
		template_matrix.push_back(new_template_row);
	}
	
	/*std::cout << "directions: ";
	printMatrix(directions);
	
	std::cout << "template: ";
	printMatrix(template_matrix);
	
	std::cout << "LB: ";
	printVector(LB);
	std::cout << "UB: ";
	printVector(UB);*/
	
  return new Bundle(directions, UB, get_complementary(LB), template_matrix, constrDirs, constrOffsets);
}

int find(const std::vector<std::vector<double>> M, const std::vector<double> v)
{
	std::vector<double> v_norm = normalize(v);
	for (unsigned i = 0; i < M.size(); i++) {
		std::vector<double> M_norm = normalize(M[i]);
		if (compare(v_norm, M_norm, 0.00001)) {
			return i;
		}
	}
	return -1;
}

void printMatrix(const std::vector<std::vector<double>> m)
{
	std::cout << "{" << std::endl;
	for (unsigned i = 0; i < m.size(); i++) {
		std::cout << "\t<";
		for (unsigned j = 0; j < m[i].size(); j++) {
			std::cout << m[i][j] << (j == m[i].size() - 1 ? "" : ", ");
		}
		std::cout << ">" << (i == m.size() - 1 ? "" : ",") << std::endl;
	}
	std::cout << "}" << std::endl;
}

void printMatrix(const std::vector<std::vector<int>> m)
{
	std::cout << "{" << std::endl;
	for (unsigned i = 0; i < m.size(); i++) {
		std::cout << "\t<";
		for (unsigned j = 0; j < m[i].size(); j++) {
			std::cout << m[i][j] << (j == m[i].size() - 1 ? "" : ", ");
		}
		std::cout << ">" << (i == m.size() - 1 ? "" : ",") << std::endl;
	}
	std::cout << "}" << std::endl;
}

void printVector(const std::vector<double> v)
{
	std::cout << "<";
	for (unsigned i = 0; i < v.size(); i++) {
		std::cout << v[i] << (i == v.size() - 1 ? "" : ", ");
	}
	std::cout << ">" << std::endl;
}

double getNormalizationCoefficient(std::vector<double> v)
{
	double res = 0;
	for (unsigned i = 0; i < v.size(); i++) {
		res += v[i]*v[i];
	}
	return 1.0 / sqrt(res);
}

std::vector<double> normalize(std::vector<double> v)
{
	double coeff = getNormalizationCoefficient(v);
	std::vector<double> res{};
	for (unsigned i = 0; i < v.size(); i++) {
		res.push_back(coeff * v[i]);
	}
	return res;
}

bool compare (std::vector<double> v1, std::vector<double> v2, double tol)
{
	if (v1.size() != v2.size()) {
		return false;
	}
	
	for (unsigned i = 0; i < v1.size(); i++) {
		if (abs(v1[i] - v2[i]) > tol) {
			return false;
		}
	}
	
	return true;
}

double rescale(double val, std::vector<double> v1, std::vector<double> v2)
{
	return val * getNormalizationCoefficient(v1) / getNormalizationCoefficient(v2);
}
