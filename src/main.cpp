/**
 * @file main.cpp
 * main: This main file reproduces the experiments reported in "Sapo:
 * Reachability Computation and Parameter Synthesis of Polynomial Dynamical
 * Systems"
 * @author Tommaso Dreossi <tommasodreossi@berkeley.edu>
 * @version 0.1
 */

#include <fstream>
#include <iostream>
#include <stdio.h>

#include "AutoGenerated.h"
#include "Bundle.h"
#include "Common.h"
#include "Sapo.h"
#include "driver.h"

using namespace std;

int main(int argc, char **argv)
{

  driver drv;
  string file;

  if (argc == 1) {
    file = "-"; // causes lexer to use stdin
  } else if (argc == 2) {
    file = argv[1]; // provided file used
  } else {
    cerr << "usage: " << argv[0] << " <filename>" << endl;
    cerr << "       " << argv[0] << endl;
    return 1;
  }

  if (drv.parse(file) != 0)
    return 2;

  // Sapo's options
  sapo_opt options;
  options.trans = drv.data.getTransValue();
  options.decomp = drv.data.getDecomposition() ? 1 : 0;
  options.alpha = drv.data.getAlpha();
  options.verbose = false;

  Model *model = new AutoGenerated(drv.data);
  Sapo sapo(model, options);

  if (drv.data.getProblem() == AbsSyn::problemType::REACH) {
    Flowpipe flowpipe;
    if (model->getParams().nops() == 0) {
      flowpipe = sapo.reach(*(model->getReachSet()),
                            drv.data.getIterations()); // reachability analysis
    } else {
      flowpipe = sapo.reach(*(model->getReachSet()), *(model->getParaSet()),
                            drv.data.getIterations()); // reachability analysis
    }
    cout << "RESULTS" << endl;
    flowpipe.print();
    cout << "END RESULTS" << endl;
  } else {
    // Synthesize parameters
    std::list<LinearSystemSet> synth_params
        = sapo.synthesize(*(model->getReachSet()), *(model->getParaSet()),
                          model->getSpec(), drv.data.getMaxParameterSplits());
    
    cout << "RESULTS" << endl;
    if (every_set_is_empty(synth_params)) {
      cout << "======empty set======" << endl << endl;
    } else {
      for (auto p_it = std::cbegin(synth_params); p_it!= std::cend(synth_params); ++p_it) {
        if (p_it->size() != 0) {
          cout << "==================" << endl;
          Flowpipe F = sapo.reach(*(model->getReachSet()), *p_it,
                                    drv.data.getIterations());
          F.print();
        }
      }
    }
    cout << "END RESULTS";
    if (every_set_is_empty(synth_params)) {
      cout << endl << "======empty set======" << endl << endl;
    } else {
      for (auto p_it = std::cbegin(synth_params); p_it!= std::cend(synth_params); ++p_it) {
        if (p_it->size() != 0) {
          cout << endl << "==================" << endl;
          p_it->print();
        }
      }
    }
  }

  delete model;

  exit(EXIT_SUCCESS);
}
