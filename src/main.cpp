/**
 * @file main.cpp
 * main: This main file reproduces the experiments reported in "Sapo:
 * Reachability Computation and Parameter Synthesis of Polynomial Dynamical
 * Systems"
 * @author Tommaso Dreossi <tommasodreossi@berkeley.edu>
 * @version 0.1
 */

#include <fstream>
#include <iostream>

#include "AutoGenerated.h"
#include "Bundle.h"
#include "Sapo.h"
#include "driver.h"

using namespace std;

Sapo init_sapo(Model *model, const AbsSyn::InputData &data,
               const bool verbose = false)
{
  Sapo sapo(model);

  sapo.trans = data.getTransValue();
  sapo.decomp = data.getDecomposition() ? 1 : 0;
  sapo.alpha = data.getAlpha();
  sapo.time_horizon = data.getIterations();
  sapo.max_param_splits = data.getMaxParameterSplits();
  sapo.verbose = verbose;

  return sapo;
}

template<typename T>
class OutputFormatter
{
public:
  OutputFormatter() {}

  static std::string flowpipe_header()
  {
    return "";
  }

  static std::string flowpipe_footer()
  {
    return "";
  }

  static std::string parameter_header()
  {
    return "";
  }

  static std::string parameter_footer()
  {
    return "";
  }

  static std::string list_begin()
  {
    return "";
  }

  static std::string list_end()
  {
    return "";
  }

  static std::string list_separator()
  {
    return "";
  }

  static std::string empty_list()
  {
    return "";
  }

  static std::string data_header()
  {
    return "";
  }

  static std::string data_footer()
  {
    return "";
  }

  static std::string data_separator()
  {
    return "";
  }
};

template<>
class OutputFormatter<std::ostream>
{
public:
  OutputFormatter() {}

  static std::string flowpipe_header()
  {
    return "FLOWPIPES\n";
  }

  static std::string flowpipe_footer()
  {
    return "";
  }

  static std::string parameter_header()
  {
    return "PARAMETER SETS\n";
  }

  static std::string parameter_footer()
  {
    return "";
  }

  static std::string list_begin()
  {
    return "=================\n";
  }

  static std::string list_end()
  {
    return "\n";
  }

  static std::string list_separator()
  {
    return "\n\n=================\n";
  }

  static std::string empty_list()
  {
    return "----empty set----";
  }

  static std::string data_header()
  {
    return "";
  }

  static std::string data_footer()
  {
    return "";
  }

  static std::string data_separator()
  {
    return "\n";
  }
};

template<>
class OutputFormatter<JSON::ostream>
{
public:
  OutputFormatter() {}

  static std::string flowpipe_header()
  {
    return "\"flowpipes\":";
  }

  static std::string flowpipe_footer()
  {
    return "";
  }

  static std::string parameter_header()
  {
    return "\"parameter sets\":";
  }

  static std::string parameter_footer()
  {
    return "";
  }

  static std::string list_begin()
  {
    return "[";
  }

  static std::string list_end()
  {
    return "]";
  }

  static std::string list_separator()
  {
    return ",";
  }

  static std::string empty_list()
  {
    return "[]";
  }

  static std::string data_header()
  {
    return "{";
  }

  static std::string data_footer()
  {
    return "}";
  }

  static std::string data_separator()
  {
    return ",";
  }
};

template<typename OSTREAM>
void reach_analysis(OSTREAM &os, Sapo &sapo, const Model *model)
{
  OutputFormatter<OSTREAM> of;

  os << of.data_header() << of.flowpipe_header() << of.list_begin();

  // if the model does not specify any parameter set
  if (model->getParams().nops() == 0) {

    // perform the reachability analysis
    os << sapo.reach(*(model->getReachSet()), sapo.time_horizon);
  } else {

    // perform the parametric reachability analysis
    os << sapo.reach(*(model->getReachSet()), *(model->getParaSet()),
                     sapo.time_horizon);
  }

  os << of.list_end() << of.flowpipe_footer() << of.data_footer();
}

template<typename OSTREAM, typename R>
void apply_parameters_and_print(
    OSTREAM &os, Sapo &sapo, const std::list<LinearSystemSet> &synth_params,
    std::function<R(Sapo &, const LinearSystemSet &)> funct)
{
  OutputFormatter<OSTREAM> of;

  if (every_set_is_empty(synth_params)) {
    os << of.list_begin() << of.empty_list() << of.list_end();

    return;
  }

  os << of.list_begin();
  bool not_first = false;
  for (auto p_it = std::cbegin(synth_params); p_it != std::cend(synth_params);
       ++p_it) {
    if (p_it->size() != 0) {
      if (not_first) {
        os << of.list_separator();
      }
      not_first = true;
      os << funct(sapo, *p_it);
    }
  }
  os << of.list_end();
}

template<typename OSTREAM>
void synthesis(OSTREAM &os, Sapo &sapo, const Model *model)
{
  OutputFormatter<OSTREAM> of;

  // Synthesize parameters
  std::list<LinearSystemSet> synth_params
      = sapo.synthesize(*(model->getReachSet()), *(model->getParaSet()),
                        model->getSpec(), sapo.max_param_splits);

  std::function<Flowpipe(Sapo &, const LinearSystemSet &)> reachability
      = [model](Sapo &sapo, const LinearSystemSet &pSet) {
          return sapo.reach(*(model->getReachSet()), pSet, sapo.time_horizon);
        };

  os << of.data_header() << of.flowpipe_header();
  apply_parameters_and_print(os, sapo, synth_params, reachability);

  os << of.flowpipe_footer() << of.data_separator() << of.parameter_header();

  std::function<LinearSystemSet(Sapo &, const LinearSystemSet &)> identity
      = [](Sapo &sapo, const LinearSystemSet &pSet) {
          (void)sapo; // this is just to avoid the warning

          return pSet;
        };
  apply_parameters_and_print(os, sapo, synth_params, identity);

  os << of.parameter_footer() << of.data_footer();
}

template<typename OSTREAM>
void perform_computation_and_get_output(OSTREAM &os, Sapo &sapo, Model *model,
                                        const AbsSyn::problemType &type)
{
  switch (type) {
  case AbsSyn::problemType::REACH:
    reach_analysis(os, sapo, model);
    break;
  case AbsSyn::problemType::SYNTH:
    synthesis(os, sapo, model);
    break;
  default:
    std::cerr << "Unsupported problem type" << std::endl;
    exit(EXIT_FAILURE);
  }
}

struct prog_opts {
  std::string input_filename;
  bool JSON_output;
  bool get_help;
};

void print_help(std::ostream &os, const std::string exec_name)
{
  os << "Usage: " << exec_name << " [options] [input filename]" << std::endl
     << "Options:" << std::endl
     << "  -h\t\tPrint this help" << std::endl
     << "  -j\t\tGet the output in JSON format" << std::endl
     << std::endl
     << "If either the filename is \"-\" or no filename is provided, "
     << "the input is taken " << std::endl
     << " from the standard input." << std::endl;
}

prog_opts parse_opts(const int argc, char **argv)
{
  prog_opts opts = {"-", false, false};

  if (argc > 3) {
    std::cerr << "Syntax error: Too many parameters" << std::endl;
    print_help(std::cerr, argv[0]);

    exit(EXIT_FAILURE);
  }

  for (int i = 1; i < argc; i++) {
    std::string argv_str = std::string(argv[i]);
    if (std::string("-h") == argv_str) {
      opts.get_help = true;
    } else {
      if (std::string("-j") == argv_str) {
        opts.JSON_output = true;
      } else {
        opts.input_filename = argv_str;
      }
    }
  }

  return opts;
}

int main(int argc, char **argv)
{
  driver drv;
  string file;

  prog_opts opts = parse_opts(argc, argv);

  if (opts.get_help) {
    print_help(std::cout, argv[0]);

    exit(EXIT_SUCCESS);
  }

  if (drv.parse(opts.input_filename) != 0) {
    std::cerr << "Error in loading " << opts.input_filename << std::endl;
    exit(EXIT_FAILURE);
  }

  Model *model = new AutoGenerated(drv.data);
  Sapo sapo = init_sapo(model, drv.data);

  if (opts.JSON_output) {
    JSON::ostream os(std::cout);
    perform_computation_and_get_output(os, sapo, model, drv.data.getProblem());
  } else {
    perform_computation_and_get_output(std::cout, sapo, model,
                                       drv.data.getProblem());
  }

  delete model;

  exit(EXIT_SUCCESS);
}
