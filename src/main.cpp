/**
 * @file main.cpp
 * main: This main file reproduces the experiments reported in "Sapo:
 * Reachability Computation and Parameter Synthesis of Polynomial Dynamical
 * Systems"
 * @author Tommaso Dreossi <tommasodreossi@berkeley.edu>
 * @version 0.1
 */

#include <fstream>
#include <iostream>

#include "AutoGenerated.h"
#include "Bundle.h"
#include "Sapo.h"
#include "Version.h"
#include "driver.h"

using namespace std;

Sapo init_sapo(Model *model, const AbsSyn::InputData &data,
               const bool verbose = false)
{
  Sapo sapo(model);

  sapo.trans = data.getTransValue();
  sapo.decomp = data.getDecomposition() ? 1 : 0;
  sapo.alpha = data.getAlpha();
  sapo.time_horizon = data.getIterations();
  sapo.max_param_splits = data.getMaxParameterSplits();
  sapo.verbose = verbose;

  return sapo;
}

template<typename OSTREAM>
OSTREAM &operator<<(OSTREAM &os, const GiNaC::lst &list)
{
  using OF = OutputFormatter<OSTREAM>;

  os << OF::short_list_begin();
  bool not_first = false;
  for (auto v_it = std::begin(list); v_it != std::end(list); ++v_it) {
    if (not_first) {
      os << OF::short_list_separator();
    } else {
      not_first = true;
    }
    {
      ostringstream buffer;
      buffer << "\"" << *v_it << "\"";

      os << buffer.str();
    }
  }
  os << OF::short_list_end();

  return os;
}

template<typename OSTREAM>
void print_variables_and_parameters(OSTREAM &os, const Model *model)
{
  using OF = OutputFormatter<OSTREAM>;

  os << OF::field_header("variables") << model->getVars()
     << OF::field_footer();
  if (model->getParams().nops() != 0) {
    os << OF::field_separator() << OF::field_header("parameters")
       << model->getParams() << OF::field_footer();
  }
}

template<typename OSTREAM>
void reach_analysis(OSTREAM &os, Sapo &sapo, const Model *model)
{
  using OF = OutputFormatter<OSTREAM>;

  os << OF::object_header();
  print_variables_and_parameters(os, model);
  os << OF::field_separator() << OF::field_header("data");

  os << OF::list_begin() << OF::object_header()
     << OF::field_header("flowpipe");

  // if the model does not specify any parameter set
  if (model->getParams().nops() == 0) {

    // perform the reachability analysis
    os << sapo.reach(*(model->getReachSet()), sapo.time_horizon);
  } else {

    // perform the parametric reachability analysis
    os << sapo.reach(*(model->getReachSet()), *(model->getParaSet()),
                     sapo.time_horizon);
  }

  os << OF::field_footer() << OF::object_footer() << OF::list_end()
     << OF::field_footer() << OF::object_footer();
}

template<typename OSTREAM>
void synthesis(OSTREAM &os, Sapo &sapo, const Model *model)
{
  using OF = OutputFormatter<OSTREAM>;

  // Synthesize parameters
  std::list<LinearSystemSet> synth_params
      = sapo.synthesize(*(model->getReachSet()), *(model->getParaSet()),
                        model->getSpec(), sapo.max_param_splits);

  os << OF::object_header();
  print_variables_and_parameters(os, model);
  os << OF::field_separator() << OF::field_header("data");

  if (every_set_is_empty(synth_params)) {
    os << OF::empty_list();
  } else {
    os << OF::list_begin();
    bool not_first = false;
    for (auto p_it = std::cbegin(synth_params);
         p_it != std::cend(synth_params); ++p_it) {
      if (p_it->size() != 0) {
        if (not_first) {
          os << OF::list_separator();
        }
        not_first = true;
        os << OF::object_header() << OF::field_header("parameter set") << *p_it
           << OF::field_footer() << OF::field_separator()
           << OF::field_header("flowpipe")
           << sapo.reach(*(model->getReachSet()), *p_it, sapo.time_horizon)
           << OF::field_footer() << OF::object_footer();
      }
    }
    os << OF::list_end();
  }
  os << OF::field_footer() << OF::object_footer();
}

template<typename OSTREAM>
void perform_computation_and_get_output(OSTREAM &os, Sapo &sapo, Model *model,
                                        const AbsSyn::problemType &type)
{
  switch (type) {
  case AbsSyn::problemType::REACH:
    reach_analysis(os, sapo, model);
    break;
  case AbsSyn::problemType::SYNTH:
    synthesis(os, sapo, model);
    break;
  default:
    std::cerr << "Unsupported problem type" << std::endl;
    exit(EXIT_FAILURE);
  }
}

struct prog_opts {
  std::string input_filename;
  bool JSON_output;
  bool get_help;
};

void print_help(std::ostream &os, const std::string exec_name)
{
  os << "Sapo " << sapo_version << std::endl
     << "Usage: " << exec_name << " [options] [input filename]" << std::endl
     << "Options:" << std::endl
     << "  -h\t\tPrint this help" << std::endl
     << "  -j\t\tGet the output in JSON format" << std::endl
     << std::endl
     << "If either the filename is \"-\" or no filename is provided, "
     << "the input is taken " << std::endl
     << " from the standard input." << std::endl;
}

prog_opts parse_opts(const int argc, char **argv)
{
  prog_opts opts = {"-", false, false};

  if (argc > 3) {
    std::cerr << "Syntax error: Too many parameters" << std::endl;
    print_help(std::cerr, argv[0]);

    exit(EXIT_FAILURE);
  }

  for (int i = 1; i < argc; i++) {
    std::string argv_str = std::string(argv[i]);
    if (std::string("-h") == argv_str) {
      opts.get_help = true;
    } else {
      if (std::string("-j") == argv_str) {
        opts.JSON_output = true;
      } else {
        opts.input_filename = argv_str;
      }
    }
  }

  return opts;
}

int main(int argc, char **argv)
{
  driver drv;
  string file;

  prog_opts opts = parse_opts(argc, argv);

  if (opts.get_help) {
    print_help(std::cout, argv[0]);

    exit(EXIT_SUCCESS);
  }

  if (drv.parse(opts.input_filename) != 0) {
    std::cerr << "Error in loading " << opts.input_filename << std::endl;
    exit(EXIT_FAILURE);
  }

  Model *model = new AutoGenerated(drv.data);
  Sapo sapo = init_sapo(model, drv.data);

  if (opts.JSON_output) {
    JSON::ostream os(std::cout);
    perform_computation_and_get_output(os, sapo, model, drv.data.getProblem());
  } else {
    perform_computation_and_get_output(std::cout, sapo, model,
                                       drv.data.getProblem());
  }

  delete model;

  exit(EXIT_SUCCESS);
}
