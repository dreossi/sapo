/**
 * @file main.cpp
 * main: This main file reproduces the experiments reported in "Sapo:
 * Reachability Computation and Parameter Synthesis of Polynomial Dynamical
 * Systems"
 * @author Tommaso Dreossi <tommasodreossi@berkeley.edu>
 * @version 0.1
 */

#include <fstream>
#include <iostream>
#include <sstream>

#ifdef WITH_THREADS
#include "ThreadPool.h"

ThreadPool thread_pool(0);

#endif // WITH_THREADS

#include "AutoGenerated.h"
#include "Bundle.h"
#include "Sapo.h"
#include "Version.h"
#include "driver.h"

using namespace std;

Sapo init_sapo(Model *model, const AbsSyn::InputData &data,
               const unsigned int num_of_presplits, const bool verbose = false)
{
  Sapo sapo(model);

  sapo.trans = data.getTransValue();
  sapo.decomp = data.getDecomposition() ? 1 : 0;
  sapo.decomp_weight = data.getAlpha();
  sapo.time_horizon = data.getIterations();
  sapo.max_param_splits = data.getMaxParameterSplits();
  if (data.isPreSplitsSet()) {
    sapo.num_of_presplits = num_of_presplits;
  } else {
    sapo.num_of_presplits = 0;
  }
  sapo.verbose = verbose;

  return sapo;
}

template<typename OSTREAM>
void print_symbol_vector(OSTREAM &os,
                         const std::vector<SymbolicAlgebra::Symbol<>> &vect)
{
  using OF = OutputFormatter<OSTREAM>;

  os << OF::short_list_begin();
  bool not_first = false;
  for (auto v_it = std::begin(vect); v_it != std::end(vect); ++v_it) {
    if (not_first) {
      os << OF::short_list_separator();
    } else {
      not_first = true;
    }
    {
      ostringstream buffer;
      buffer << "\"" << *v_it << "\"";

      os << buffer.str();
    }
  }
  os << OF::short_list_end();
}

template<typename OSTREAM>
void print_variables_and_parameters(OSTREAM &os, const Model *model)
{
  using OF = OutputFormatter<OSTREAM>;

  os << OF::field_header("variables");
  print_symbol_vector(os, model->getVars());
  os << OF::field_footer();
  if (model->getParams().size() != 0) {
    os << OF::field_separator() << OF::field_header("parameters");
    print_symbol_vector(os, model->getParams());
    os << OF::field_footer();
  }
}

template<typename OSTREAM>
void reach_analysis(OSTREAM &os, Sapo &sapo, const Model *model)
{
  using OF = OutputFormatter<OSTREAM>;

  os << OF::object_header();
  print_variables_and_parameters(os, model);
  os << OF::field_separator() << OF::field_header("data");

  os << OF::list_begin() << OF::object_header()
     << OF::field_header("flowpipe");

  // if the model does not specify any parameter set
  if (model->getParams().size() == 0) {

    // perform the reachability analysis
    os << sapo.reach(*(model->getReachSet()), sapo.time_horizon);
  } else {

    // perform the parametric reachability analysis
    os << sapo.reach(*(model->getReachSet()), *(model->getParaSet()),
                     sapo.time_horizon);
  }

  os << OF::field_footer() << OF::object_footer() << OF::list_end()
     << OF::field_footer() << OF::object_footer();
}

template<typename OSTREAM>
void output_synthesis(OSTREAM &os, const Model *model,
                      const std::list<PolytopesUnion> &synth_params,
                      const std::vector<Flowpipe> &flowpipes)
{
  using OF = OutputFormatter<OSTREAM>;

  os << OF::object_header();
  print_variables_and_parameters(os, model);
  os << OF::field_separator() << OF::field_header("data");

  if (every_set_is_empty(synth_params)) {
    os << OF::empty_list();
  } else {
    os << OF::list_begin();
    bool not_first = false;
    unsigned int params_idx = 0;
    for (auto p_it = std::cbegin(synth_params);
         p_it != std::cend(synth_params); ++p_it) {
      if (p_it->size() != 0) {
        if (not_first) {
          os << OF::list_separator();
        }
        not_first = true;
        os << OF::object_header() << OF::field_header("parameter set") << *p_it
           << OF::field_footer() << OF::field_separator()
           << OF::field_header("flowpipe") << flowpipes[params_idx++]
           << OF::field_footer() << OF::object_footer();
      } else {
        ++params_idx;
      }
    }
    os << OF::list_end();
  }
  os << OF::field_footer() << OF::object_footer();
}

template<typename OSTREAM>
void synthesis(OSTREAM &os, Sapo &sapo, const Model *model)
{
  // Synthesize parameters
  std::list<PolytopesUnion> synth_params = sapo.synthesize(
      *(model->getReachSet()), *(model->getParaSet()), model->getSpec(),
      sapo.max_param_splits, sapo.num_of_presplits);

  std::vector<Flowpipe> flowpipes(synth_params.size());

  if (!every_set_is_empty(synth_params)) {
#ifdef WITH_THREADS
    auto compute_reachability
        = [&flowpipes, &sapo, &model](const PolytopesUnion &pSet,
                                      unsigned int params_idx) {
            flowpipes[params_idx]
                = sapo.reach(*(model->getReachSet()), pSet, sapo.time_horizon);
          };

    ThreadPool::BatchId batch_id = thread_pool.create_batch();

    unsigned int res_idx = 0;
    for (auto p_it = std::cbegin(synth_params);
         p_it != std::cend(synth_params); ++p_it) {
      // submit the task to the thread pool
      thread_pool.submit_to_batch(
          batch_id,
          std::bind(compute_reachability, std::ref(*p_it), res_idx++));
    }

    // join to the pool threads
    thread_pool.join_threads(batch_id);

    // close the batch
    thread_pool.close_batch(batch_id);
#else
    unsigned int params_idx = 0;
    for (auto p_it = std::cbegin(synth_params);
         p_it != std::cend(synth_params); ++p_it) {
      flowpipes[params_idx++]
          = sapo.reach(*(model->getReachSet()), *p_it, sapo.time_horizon);
    }
#endif
  }

  output_synthesis(os, model, synth_params, flowpipes);
}

template<typename OSTREAM>
void perform_computation_and_get_output(OSTREAM &os, Sapo &sapo, Model *model,
                                        const AbsSyn::problemType &type)
{
  switch (type) {
  case AbsSyn::problemType::REACH:
    reach_analysis(os, sapo, model);
    break;
  case AbsSyn::problemType::SYNTH:
    synthesis(os, sapo, model);
    break;
  default:
    std::cerr << "Unsupported problem type" << std::endl;
    exit(EXIT_FAILURE);
  }
}

struct prog_opts {
  std::string input_filename;
  bool JSON_output;
  bool get_help;
  unsigned int num_of_threads;
};

void print_help(std::ostream &os, const std::string exec_name)
{
  os << "Sapo " << sapo_version << std::endl
     << "Usage: " << exec_name << " [options] [input filename]" << std::endl
     << "Options:" << std::endl
     << "  -j\t\t\t\tGet the output in JSON format" << std::endl
#ifdef WITH_THREADS
     << "  -t [num of active threads]\tEnable multi-threading and set the "
     << "number of " << std::endl
     << "\t\t\t\t  active threads (default: "
     << std::thread::hardware_concurrency() << ")" << std::endl
#endif
     << "  -h\t\t\t\tPrint this help" << std::endl
     << std::endl
     << "If either the filename is \"-\" or no filename is provided, "
     << "the input is taken " << std::endl
     << " from the standard input." << std::endl;
}

bool is_number(const char *str)
{
  unsigned int i = 0;
  while (str[i] != '\0') {
    if (!std::isdigit(str[i])) {
      return false;
    }

    i++;
  }

  return true;
}

prog_opts parse_opts(const int argc, char **argv)
{
  prog_opts opts = {"-", false, false, 1};

#ifdef WITH_THREADS
  if (argc > 5) {
#else
  if (argc > 3) {
#endif
    std::cerr << "Syntax error: Too many parameters" << std::endl;
    print_help(std::cerr, argv[0]);

    exit(EXIT_FAILURE);
  }

  for (int i = 1; i < argc; i++) {
    std::string argv_str = std::string(argv[i]);
    if (std::string("-h") == argv_str) {
      opts.get_help = true;
    } else {
      if (std::string("-j") == argv_str) {
        opts.JSON_output = true;
      } else {
#ifdef WITH_THREADS
        if (std::string("-t") == argv_str) {
          if (i + 1 < argc && is_number(argv[i + 1])) {
            opts.num_of_threads = atoi(argv[++i]);
          } else {
            opts.num_of_threads = std::thread::hardware_concurrency();
          }
        } else {
          opts.input_filename = argv_str;
        }
#else
        opts.input_filename = argv_str;
#endif
      }
    }
  }

  return opts;
}

int main(int argc, char **argv)
{
  driver drv;
  string file;

  prog_opts opts = parse_opts(argc, argv);

#ifdef WITH_THREADS
  // add all the aimed threads, but the current
  // one to the thread pool
  thread_pool.reset(opts.num_of_threads - 1);
#endif

  if (opts.get_help) {
    print_help(std::cout, argv[0]);

    exit(EXIT_SUCCESS);
  }

  if (drv.parse(opts.input_filename) != 0) {
    std::cerr << "Error in loading " << opts.input_filename << std::endl;
    exit(EXIT_FAILURE);
  }

  Model *model = new AutoGenerated(drv.data);

#ifdef WITH_THREADS
  Sapo sapo = init_sapo(model, drv.data, opts.num_of_threads);
#else
  Sapo sapo = init_sapo(model, drv.data, 0);
#endif

  if (opts.JSON_output) {
    JSON::ostream os(std::cout);
    perform_computation_and_get_output(os, sapo, model, drv.data.getProblem());
  } else {
    perform_computation_and_get_output(std::cout, sapo, model,
                                       drv.data.getProblem());
  }

  delete model;

  exit(EXIT_SUCCESS);
}
